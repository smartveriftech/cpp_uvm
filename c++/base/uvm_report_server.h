//
//------------------------------------------------------------------------------
// Copyright 2007-2010 Mentor Graphics Corporation
// Copyright 2007-2011 Cadence Design Systems, Inc. 
// Copyright 2010 Synopsys, Inc.
// Copyright 2014 NVIDIA Corporation
// Copyright 2025-2035 Smart Verification Technology Corporation (智验科技)
// All Rights Reserved Worldwide
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef UVM_REPORT_SERVER_H
#define UVM_REPORT_SERVER_H

#include <string>
#include <iostream>
#include <map>
#include <fstream> // Include this header for std::ofstream

#include "base/uvm_globals.h"
#include "base/uvm_object.h"

class uvm_report_object;

//------------------------------------------------------------------------------
//
// CLASS: uvm_report_server
//
// uvm_report_server is a global server that processes all of the reports
// generated by an uvm_report_handler. None of its methods are intended to be
// called by normal testbench code, although in some circumstances the virtual
// methods process_report and/or compose_uvm_info may be overloaded in a
// subclass.
//
//------------------------------------------------------------------------------
class uvm_report_server : public uvm_object {

public:

    // Needed for callbacks
    virtual std::string get_type_name() override;

    // Function: set_server
    //
    // Sets the global report server to use for reporting. The report
    // server is responsible for formatting messages.
    static void set_server(uvm_report_server* server);

    // Function: get_server
    //
    // Gets the global report server. The method will always return 
    // a valid handle to a report server.
    static uvm_report_server* get_server();

    void set_max_quit_count(int count, bool overridable = true);

    // Function: get_max_quit_count
    //
    // Get or set the maximum number of COUNT actions that can be tolerated
    // before an UVM_EXIT action is taken. The default is 0, which specifies
    // no maximum.
    int get_max_quit_count();

    void set_quit_count(int count);
    
    int get_quit_count();
    void incr_quit_count();

    // Function: reset_quit_count
    //
    // Set, get, increment, or reset to 0 the quit count, i.e., the number of
    // COUNT actions issued.
    void reset_quit_count();

    // Function: is_quit_count_reached
    //
    // If is_quit_count_reached returns 1, then the quit counter has reached
    // the maximum.
    bool is_quit_count_reached();

    void set_severity_count(uvm_severity severity, int count);
    int get_severity_count(uvm_severity severity);
    void incr_severity_count(uvm_severity severity);

    // Function: reset_severity_counts
    //
    // Set, get, or increment the counter for the given severity, or reset
    // all severity counters to 0.
    void reset_severity_counts();

    void set_id_count(const std::string& id, int count);
    int get_id_count(const std::string& id);

    // Function: incr_id_count
    //
    // Set, get, or increment the counter for reports with the given id.
    void incr_id_count(const std::string& id);

    // f_display
    //
    // This method sends string severity to the command line if file is 0 and to
    // the file(s) specified by file if it is not 0.
    void f_display(UVM_FILE file, const std::string& str);

    void report(uvm_severity severity, const std::string& name, const std::string& id, const std::string& message, int verbosity_level, const std::string& filename, int line, uvm_report_object* client);

    // Function: process_report
    //
    // Calls <compose_message> to construct the actual message to be
    // output. It then takes the appropriate action according to the value of
    // action and file. 
    //
    // This method can be overloaded by expert users to customize the way the
    // reporting system processes reports and the actions enabled for them.
    void process_report(uvm_severity severity, const std::string& name, const std::string& id, const std::string& message, uvm_action action, UVM_FILE file, const std::string& filename, int line, const std::string& composed_message, int verbosity_level, uvm_report_object* client);

    // Function: compose_message
    //
    // Constructs the actual string sent to the file or command line
    // from the severity, component name, report id, and the message itself. 
    //
    // Expert users can overload this method to customize report formatting.
    std::string compose_message(uvm_severity severity, const std::string& name, const std::string& id, const std::string& message, const std::string& filename, int line);

    // Function: summarize
    //
    // See <uvm_report_object::report_summarize> method.
    void summarize(UVM_FILE file = 0);

    // Function: dump_server_state
    //
    // Dumps server state information.
    void dump_server_state();

//private:

    // Function: new
    //
    // Creates the central report server, if not already created. Else, does
    // nothing. The constructor is protected to enforce a singleton.
    uvm_report_server();

    static uvm_report_server* m_global_report_server;

    int max_quit_count;
    int quit_count;

    std::map<uvm_severity, int> severity_count;

    // Variable: id_count
    //
    // An associative array holding the number of occurences
    // for each unique report ID.
    std::map<std::string, int> id_count;

    bool enable_report_id_count_summary = true;

    bool m_max_quit_overridable = true;

    void copy_severity_counts(uvm_report_server* dst);
    void copy_id_counts(uvm_report_server* dst);
};

#endif // UVM_REPORT_SERVER_H